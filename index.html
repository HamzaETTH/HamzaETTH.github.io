<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <title>Hamza E</title>
    <link href="./css/style.css" rel="stylesheet" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="manifest" href="/site.webmanifest" />
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5" />
    <link href="https://fonts.googleapis.com/css?family=Fira+Code:normal&display=swap" rel="stylesheet" />
    <meta name="msapplication-TileColor" content="#da532c" />
    <meta name="theme-color" content="#ffffff" />
  </head>

  <body>
    <main class="site-content">
      <div id="particle-canvas"></div>
      <section class="features-tiles section">
        <div class="container">
          <div class="typewriter">
            <div class="center center-text">
              <h1 class="typewriter">Hamza E<span role="img" aria-label="waving brown hand emoji"> üëãüèΩ</span></h1>
              <br />
              <br />
              <br />
              <div class="blobs-container">
                <div class="blob white"></div>
                <div class="blob yellow"></div>
                <div class="blob orange"></div>
                <div class="blob red"></div>
                <div class="blob blue"></div>
                <div class="blob red"></div>
                <div class="blob orange"></div>
                <div class="blob yellow"></div>
                <div class="blob white"></div>
              </div>
            </div>
          </div>
        </div>
      </section>
    </main>
    <!-- Load modules in the right order -->
    <script src="./js/Config.js"></script>
    <script src="./js/ColorUtils.js"></script>
    <script src="./js/PerformanceMonitor.js"></script>
    <script src="./js/ParticleRenderer.js"></script>
    <script src="./js/ParticleRendererGL.js"></script>
    <script src="./js/ParticleNetwork.js"></script>
    <script>
      // Initialize on page load
      document.addEventListener('DOMContentLoaded', function() {
        // Access the existing particleInstance
        console.log('Initialized: particleInstance exists =', !!window.particleInstance);
        if (window.particleInstance) {
          console.log('performanceMonitor exists =', !!window.particleInstance.performanceMonitor);
        }
      });
      
      // Color method cycling
      const colorMethods = [
        'hueDistance',
        'complementary',
        'triadic',
        'analogous', 
        'labPerceptual',
        'wcagContrast'
      ];
      
      let currentColorMethodIndex = 0;
      
      // Method to cycle to the next color method
      function cycleColorMethod() {
        currentColorMethodIndex = (currentColorMethodIndex + 1) % colorMethods.length;
        const newMethod = colorMethods[currentColorMethodIndex];
        
        console.log('Color method changed to:', newMethod);
        
        // Show temporary indicator of which method is active
        const methodIndicator = document.createElement('div');
        methodIndicator.textContent = `Color Method: ${newMethod}`;
        methodIndicator.style.position = 'fixed';
        methodIndicator.style.top = '10px';
        methodIndicator.style.right = '10px';
        methodIndicator.style.background = 'rgba(0,0,0,0.7)';
        methodIndicator.style.color = 'white';
        methodIndicator.style.padding = '8px 12px';
        methodIndicator.style.borderRadius = '4px';
        methodIndicator.style.fontFamily = 'Fira Code, monospace';
        methodIndicator.style.zIndex = '1000';
        document.body.appendChild(methodIndicator);
        
        // Remove the indicator after 2 seconds
        setTimeout(() => {
          document.body.removeChild(methodIndicator);
        }, 2000);
        
        // Direct manipulation of the colors of the auto-created instance
        if (window.ColorUtils && window.ColorDiffMethod && window.particleInstance) {
          const methodName = newMethod.toUpperCase();
          const method = window.ColorDiffMethod[methodName] || window.ColorDiffMethod.HUE_DISTANCE;
          
          // Get the lineHue1 from the existing network and generate a new lineHue2
          if (window.particleInstance.lineHue1) {
            // Generate new color based on the selected method
            window.particleInstance.lineHue2 = window.ColorUtils.generateDistinctColor(
              window.particleInstance.lineHue1, 
              method,
              {}
            );
          }
        }
      }
      
      // Add key event listener for 'M' key (color method cycle)
      window.addEventListener('keydown', function(event) {
        // Check if 'm' or 'M' was pressed
        if (event.key.toLowerCase() === 'm') {
          console.log('M key pressed');
          cycleColorMethod();
        }
        
        // Check if 'p' or 'P' was pressed to toggle performance overlay
        if (event.key.toLowerCase() === 'p') {
          if (window.particleInstance && window.particleInstance.performanceMonitor && window.particleInstance.options) {
            const monitor = window.particleInstance.performanceMonitor;
            monitor.toggleOverlay();
            const overlayEnabled = monitor.options.showOverlay;
            // Sync back to main options so other code (e.g., UI) doesn't fight it
            window.particleInstance.options.performanceOverlay = overlayEnabled;

            const statusIndicator = document.createElement('div');
            statusIndicator.textContent = `Performance Overlay: ${overlayEnabled ? 'Enabled' : 'Disabled'}`;
            statusIndicator.style.position = 'fixed';
            statusIndicator.style.top = '10px';
            statusIndicator.style.right = '10px';
            statusIndicator.style.background = 'rgba(0,0,0,0.7)';
            statusIndicator.style.color = 'white';
            statusIndicator.style.padding = '8px 12px';
            statusIndicator.style.borderRadius = '4px';
            statusIndicator.style.fontFamily = 'Fira Code, monospace';
            statusIndicator.style.zIndex = '4000';
            document.body.appendChild(statusIndicator);
            setTimeout(() => { if (statusIndicator.parentNode) document.body.removeChild(statusIndicator); }, 2000);
          } else {
            console.error('Could not access performanceMonitor.');
          }
        }
      });
      
      console.log('Color cycling script loaded. Press M to cycle through color methods.');
      console.log('Press P to toggle performance overlay.');
    </script>
    <script type="module">
      import {Pane} from 'https://cdn.jsdelivr.net/npm/tweakpane@4.0.5/dist/tweakpane.min.js';

      // Utility: create container for pane we can show/hide
      function ensurePaneContainer() {
        let el = document.getElementById('tp-container');
        if (!el) {
          el = document.createElement('div');
          el.id = 'tp-container';
          el.style.position = 'fixed';
          el.style.top = '12px';
          el.style.right = '12px';
          el.style.zIndex = '2000';
          el.style.display = 'none';
          document.body.appendChild(el);
        }
        return el;
      }

      function buildParamsFromNetwork(pn) {
        const o = pn.options || {};
        return {
          // Background
          background: o.background || '#000000',

          // Particles
          particleColor: o.particleColor || '#ffffff',
          particleSize: o.particleSize != null ? o.particleSize : 2,
          particleColorCycling: !!o.particleColorCycling,
          particleCyclingSpeed: o.particleCyclingSpeed != null ? o.particleCyclingSpeed : 10,
          particleRepulsion: !!o.particleRepulsion,
          particleAttraction: !!o.particleAttraction,
          particleAttractionForce: o.particleAttractionForce != null ? o.particleAttractionForce : 5,
          particleCollision: !!o.particleCollision,

          // Lines
          gradientEffect: o.gradientEffect !== false,
          gradientColor1: o.gradientColor1 || '#00bfff',
          gradientColor2: o.gradientColor2 || '#ff4500',
          lineColorCycling: o.lineColorCycling !== false,
          lineCyclingSpeed: o.lineCyclingSpeed != null ? o.lineCyclingSpeed : 50,
          randomizeDistanceColors: !!o.randomizeDistanceColors,
          colorDifferentiationMethod: (o.colorDifferentiationMethod || 'hueDistance'),
          distanceColorCyclingSpeed: o.distanceColorCyclingSpeed != null ? o.distanceColorCyclingSpeed : (o.lineCyclingSpeed != null ? o.lineCyclingSpeed : 50),

          // Interaction
          interactive: o.interactive !== false,
          proximityEffectColor: o.proximityEffectColor || '#ff0000',
          proximityEffectDistance: o.proximityEffectDistance != null ? o.proximityEffectDistance : 100,
          // UI shows radius in px; internal stores units (px/10)
          attractionRange: o.attractionRange != null ? (o.attractionRange * 10) : 10,
          attractionIntensity: o.attractionIntensity != null ? o.attractionIntensity : 1,
          repulsionRange: o.repulsionRange != null ? (o.repulsionRange * 10) : 10,
          repulsionIntensity: o.repulsionIntensity != null ? o.repulsionIntensity : 1,

          // Physics
          speed: typeof o.velocity === 'number' ? o.velocity : 0.66,
          density: pn.options && pn.options.density ? pn.options.density : 10000,
          boundaryMode: o.boundaryMode || 'bounce',

          // Effects
          opacity: o.opacity != null ? o.opacity : 0.7,
          useDistanceEffect: !!o.useDistanceEffect,
          maxColorChangeDistance: o.maxColorChangeDistance != null ? o.maxColorChangeDistance : 120,
          startColor: o.startColor || '#0BDA51',
          endColor: o.endColor || '#BF00FF',
          lineConnectionDistance: o.lineConnectionDistance != null ? o.lineConnectionDistance : 120,
          particleInteractionDistance: o.particleInteractionDistance != null ? o.particleInteractionDistance : 50,
          particleRepulsionForce: o.particleRepulsionForce != null ? o.particleRepulsionForce : 5,

          // Perf
          performanceOverlay: !!o.performanceOverlay,

          // Trails
          trails: !!o.trails,
          trailFade: o.trailFade != null ? o.trailFade : 0.08,

          // Electric lines
          lineJitter: !!o.lineJitter,
          lineJitterSegments: o.lineJitterSegments != null ? o.lineJitterSegments : 6,
          lineJitterAmplitude: o.lineJitterAmplitude != null ? o.lineJitterAmplitude : 0.12,

          // Curved drift motion
          curvedDrift: !!o.curvedDrift,
          // Expose UI 1..100 (100 => internal 0.20)
          curvedDriftCurvature: o.curvedDriftCurvature != null ? Math.round(o.curvedDriftCurvature * 500) : 60,
          curvedDriftNoiseSpeed: o.curvedDriftNoiseSpeed != null ? o.curvedDriftNoiseSpeed : 1.5,

          // Gather
          gatherRadius: o.gatherRadius != null ? o.gatherRadius : 100,
        };
      }

      function buildDefaultParams() {
        const D = (window.ParticleNetworkConfig && window.ParticleNetworkConfig.DEFAULT_CONFIG) || {};
        return {
          // Background
          background: D.background || '#000000',

          // Particles
          particleColor: D.particleColor || '#fff',
          particleSize: D.particleSize != null ? D.particleSize : 2,
          particleColorCycling: !!D.particleColorCycling,
          particleCyclingSpeed: D.particleCyclingSpeed != null ? D.particleCyclingSpeed : 10,
          particleRepulsion: !!D.particleRepulsion,
          particleAttraction: !!D.particleAttraction,
          particleAttractionForce: D.particleAttractionForce != null ? D.particleAttractionForce : 5,
          particleCollision: !!D.particleCollision,

          // Lines
          gradientEffect: D.gradientEffect !== false,
          gradientColor1: D.gradientColor1 || '#00bfff',
          gradientColor2: D.gradientColor2 || '#ff4500',
          lineColorCycling: D.lineColorCycling !== false,
          lineCyclingSpeed: D.lineCyclingSpeed != null ? D.lineCyclingSpeed : 50,
          randomizeDistanceColors: !!D.randomizeDistanceColors,
          colorDifferentiationMethod: (D.colorDifferentiationMethod || (() => {
            const methods = ['hueDistance', 'complementary', 'triadic', 'analogous', 'labPerceptual', 'wcagContrast'];
            return methods[Math.floor(Math.random() * methods.length)];
          })()),
          distanceColorCyclingSpeed: D.distanceColorCyclingSpeed != null ? D.distanceColorCyclingSpeed : (D.lineCyclingSpeed != null ? D.lineCyclingSpeed : 50),

          // Interaction
          interactive: D.interactive !== false,
          proximityEffectColor: D.proximityEffectColor || '#ff0000',
          proximityEffectDistance: D.proximityEffectDistance != null ? D.proximityEffectDistance : 100,
          // UI shows radius in px; internal stores units (px/10)
          attractionRange: D.attractionRange != null ? (D.attractionRange * 10) : 10,
          attractionIntensity: D.attractionIntensity != null ? D.attractionIntensity : 1,
          repulsionRange: D.repulsionRange != null ? (D.repulsionRange * 10) : 10,
          repulsionIntensity: D.repulsionIntensity != null ? D.repulsionIntensity : 1,

          // Physics (Config has no explicit defaults for these)
          speed: 0.66,
          density: 10000,
          boundaryMode: D.boundaryMode || 'bounce',

          // Effects
          opacity: D.opacity != null ? D.opacity : 0.7,
          useDistanceEffect: !!D.useDistanceEffect,
          maxColorChangeDistance: D.maxColorChangeDistance != null ? D.maxColorChangeDistance : 120,
          startColor: D.startColor || '#0BDA51',
          endColor: D.endColor || '#BF00FF',
          lineConnectionDistance: D.lineConnectionDistance != null ? D.lineConnectionDistance : 120,
          particleInteractionDistance: D.particleInteractionDistance != null ? D.particleInteractionDistance : 50,
          particleRepulsionForce: D.particleRepulsionForce != null ? D.particleRepulsionForce : 5,

          // Perf
          performanceOverlay: !!D.performanceOverlay,

          // Trails
          trails: !!D.trails,
          trailFade: D.trailFade != null ? D.trailFade : 0.08,

          // Electric lines
          lineJitter: !!D.lineJitter,
          lineJitterSegments: D.lineJitterSegments != null ? D.lineJitterSegments : 6,
          lineJitterAmplitude: D.lineJitterAmplitude != null ? D.lineJitterAmplitude : 0.12,

          // Curved drift motion
          curvedDrift: !!D.curvedDrift,
          curvedDriftCurvature: D.curvedDriftCurvature != null ? Math.round(D.curvedDriftCurvature * 500) : 60,
          curvedDriftNoiseSpeed: D.curvedDriftNoiseSpeed != null ? D.curvedDriftNoiseSpeed : 1.5,

          // Gather
          gatherRadius: D.gatherRadius != null ? D.gatherRadius : 100,
        };
      }

      function applyParamsToNetwork(pn, p) {
        if (!pn) return;
        const o = pn.options;

        // Color helpers
        const normalizeHex = (hex) => {
          if (typeof hex !== 'string') return hex;
          const m = /^#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(hex);
          if (!m) return hex;
          return `#${m[1]}${m[1]}${m[2]}${m[2]}${m[3]}${m[3]}`;
        };
        const toCssColor = (val) => {
          if (typeof val === 'string') return normalizeHex(val);
          if (val && typeof val === 'object') {
            const r = 'r' in val ? val.r : 0;
            const g = 'g' in val ? val.g : 0;
            const b = 'b' in val ? val.b : 0;
            const a = 'a' in val ? val.a : 1;
            const ri = r > 1 ? Math.round(r) : Math.round(r * 255);
            const gi = g > 1 ? Math.round(g) : Math.round(g * 255);
            const bi = b > 1 ? Math.round(b) : Math.round(b * 255);
            const aa = a > 1 ? a / 255 : a;
            return `rgba(${ri}, ${gi}, ${bi}, ${aa})`;
          }
          return val;
        };

        // Simple assigns
         const keys = [
          'particleColor','particleColorCycling','particleCyclingSpeed','particleRepulsion','particleCollision','particleAttraction','particleAttractionForce',
          'gradientEffect','gradientColor1','gradientColor2','lineColorCycling','lineCyclingSpeed',
           'interactive','proximityEffectColor','proximityEffectDistance','attractionIntensity','repulsionIntensity',
          'opacity','useDistanceEffect','randomizeDistanceColors','maxColorChangeDistance','startColor','endColor','lineConnectionDistance','distanceColorCyclingSpeed',
          'particleInteractionDistance','particleRepulsionForce','performanceOverlay','boundaryMode','colorDifferentiationMethod',
          // Trails
          'trails','trailFade',
          // Electric lines
          'lineJitter','lineJitterSegments','lineJitterAmplitude',
          // Curved drift motion (curvature mapped separately)
          'curvedDrift','curvedDriftNoiseSpeed',
          // Gather
          'gatherRadius'
        ];
         keys.forEach(k => { o[k] = p[k]; });

         // Map UI px radius (0..300) to internal engine units (0..30) by /10
         if (typeof p.attractionRange === 'number') {
           o.attractionRange = Math.max(0, Math.min(300, p.attractionRange)) / 10;
         }
         if (typeof p.repulsionRange === 'number') {
           o.repulsionRange = Math.max(0, Math.min(300, p.repulsionRange)) / 10;
         }

        // Map UI curvedDriftCurvature 1..100 to internal 0..0.2
        if (typeof p.curvedDriftCurvature === 'number') {
          o.curvedDriftCurvature = Math.max(1, Math.min(100, Math.round(p.curvedDriftCurvature))) / 500;
        }

        // Normalize key color strings
        o.particleColor = toCssColor(o.particleColor);
        o.gradientColor1 = toCssColor(o.gradientColor1);
        o.gradientColor2 = toCssColor(o.gradientColor2);
        o.proximityEffectColor = toCssColor(o.proximityEffectColor);
        o.startColor = toCssColor(o.startColor);
        o.endColor = toCssColor(o.endColor);

        // Background update (color or image URL)
        o.background = toCssColor(p.background);
        if (pn.k) {
          const isHex = typeof o.background === 'string' && /^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(o.background);
          const isRgba = typeof o.background === 'string' && /^rgba?\(/i.test(o.background);
          const isColor = isHex || isRgba;
          if (isColor) {
            // Apply solid color to wrapper and body
            pn.k.style.background = o.background;
            pn.k.style.backgroundImage = '';
            document.body.style.background = o.background;
            document.body.style.backgroundImage = '';
          } else if (typeof o.background === 'string' && o.background.length > 0) {
            // Treat as image URL for wrapper and body
            const url = o.background;
            pn.k.style.background = '';
            pn.k.style.backgroundImage = 'url("' + url + '")';
            pn.k.style.backgroundRepeat = 'no-repeat';
            pn.k.style.backgroundPosition = 'center';
            pn.k.style.backgroundSize = 'cover';

            document.body.style.background = '';
            document.body.style.backgroundImage = 'url("' + url + '")';
            document.body.style.backgroundRepeat = 'no-repeat';
            document.body.style.backgroundPosition = 'center';
            document.body.style.backgroundSize = 'cover';
          }
        }

        // Speed/Velocity: support both PARAMS.speed and direct PARAMS.velocity
        const prevVelocity = o.velocity;
        if (typeof p.velocity === 'number') {
          o.velocity = p.velocity;
        } else {
          o.velocity = typeof p.speed === 'number' ? p.speed : pn.setVelocity(p.speed);
        }
        // If the loop was stopped (velocity 0) and we now have non-zero velocity, restart it
        if ((!pn._rafActive || pn._rafId == null) && o.velocity !== 0 && typeof pn.update === 'function') {
          pn.update();
        }

        // Density: rebuild particle arrays based on new density
        if (typeof p.density === 'number' && p.density > 0) {
          o.density = p.density;
          if (typeof pn._rebuildOnResize === 'function') pn._rebuildOnResize();
        }

        // Line grid impact
        if (typeof pn.initGrid === 'function') pn.initGrid();

        // Particle size and color reapply
        if (Array.isArray(pn.o)) {
          for (let i = 0; i < pn.o.length; i++) {
            const part = pn.o[i];
            if (part) {
              part.size = p.particleSize;
              part.particleColor = p.particleColor;
            }
          }
          // sync SoA size array if present
          if (pn.sizeA && pn.sizeA.length) {
            for (let i = 0; i < pn.sizeA.length; i++) pn.sizeA[i] = p.particleSize;
          }
        }
        o.particleSize = p.particleSize;

        // Random particle color removed; color is either static or cycling

        // Update lineHue2 if method changed
        if (window.ColorUtils && window.ColorDiffMethod && typeof window.ColorUtils.generateDistinctColor === 'function') {
          const method = window.ColorDiffMethod[(p.colorDifferentiationMethod || 'hueDistance').toUpperCase()] || window.ColorDiffMethod.HUE_DISTANCE;
          pn.lineHue2 = window.ColorUtils.generateDistinctColor(pn.lineHue1 || 0, method, o.colorDifferentiationOptions || {});
        }

        // Performance overlay
        if (pn.performanceMonitor && typeof pn.performanceMonitor.toggleOverlay === 'function') {
          pn.performanceMonitor.toggleOverlay(!!p.performanceOverlay);
        }
      }

      // Ensure global access for scripted tweaks
      window.applyParamsToNetwork = applyParamsToNetwork;

      window.addEventListener('DOMContentLoaded', () => {
        const pn = window.particleInstance;
        if (!pn) return;

        const container = ensurePaneContainer();
        const pane = new Pane({ title: 'Controls', container });

        const PARAMS = buildParamsFromNetwork(pn);
        // Snapshot current as reset baseline rather than global defaults
        const DEFAULTS = { ...PARAMS };

        // Shared reset that truly restores defaults and clears transient state
        function doReset() {
          Object.keys(DEFAULTS).forEach(k => { PARAMS[k] = DEFAULTS[k]; });
          applyParamsToNetwork(pn, PARAMS);
          // Clear transient forces and effects
          try {
            if (pn) {
              pn.attractionForce = null;
              pn.repulsionForce = null;
              pn._gatherActive = false;
              pn.forceHueSweep = false;
              // Wipe 2D canvas (clear trails immediately)
              if (pn.g && pn.i && pn.i.size) {
                pn.g.clearRect(0, 0, pn.i.size.width, pn.i.size.height);
              }
              // Wipe GL buffers
              if (pn.glRenderer && pn.glRenderer.gl) {
                const gl = pn.glRenderer.gl;
                gl.clear(gl.COLOR_BUFFER_BIT);
              }
              // Rebuild particles for a pristine state
              if (typeof pn._rebuildOnResize === 'function') pn._rebuildOnResize();
            }
          } catch (_) {}
          if (typeof pane.refresh === 'function') pane.refresh();
        }

        // Top-level Performance Overlay checkbox (pinned at top)
        pane.addBinding(PARAMS, 'performanceOverlay', { label: 'Performance Overlay' })
          .on('change', () => applyParamsToNetwork(pn, PARAMS));

        // Tabs to compact the UI
        const tabs = pane.addTab({ pages: [
          { title: 'Main' },
          { title: 'Advanced' },
        ]});

        // Quick
        const main = tabs.pages[0];
        const mainBg = main.addFolder({ title: 'Background', expanded: true });
        mainBg.addBinding(PARAMS, 'background', { view: 'color', label: 'Background' }).on('change', () => applyParamsToNetwork(pn, PARAMS));
        // Lines (core)
        const mainLines = main.addFolder({ title: 'Lines', expanded: true });
        // Distance Effect controls (moved from Advanced ‚Üí Lines, above Gradient Effect)
        const bindUseDistance = mainLines.addBinding(PARAMS, 'useDistanceEffect', { label: 'Distance Color Effect' }).on('change', () => {
          if (PARAMS.useDistanceEffect) {
            PARAMS.gradientEffect = false;
          }
          applyParamsToNetwork(pn, PARAMS);
          updateVisibility();
        });
        const bindMaxColorDist = mainLines.addBinding(PARAMS, 'maxColorChangeDistance', { min: 20, max: 400, step: 5, label: 'Max Color Change Distance' }).on('change', () => applyParamsToNetwork(pn, PARAMS));
        const bindStartColor = mainLines.addBinding(PARAMS, 'startColor', { view: 'color', label: 'Start Color' }).on('change', () => applyParamsToNetwork(pn, PARAMS));
        const bindEndColor = mainLines.addBinding(PARAMS, 'endColor', { view: 'color', label: 'End Color' }).on('change', () => applyParamsToNetwork(pn, PARAMS));
        const bindRandDistColors = mainLines.addBinding(PARAMS, 'randomizeDistanceColors', { label: 'Randomize Distance Colors' }).on('change', () => {
          if (PARAMS.randomizeDistanceColors && PARAMS.useDistanceEffect) {
            PARAMS.lineColorCycling = false;
          }
          applyParamsToNetwork(pn, PARAMS);
        });
        const bindDistCycleSpeed = mainLines.addBinding(PARAMS, 'distanceColorCyclingSpeed', { min: 0, max: 100, step: 1, label: 'Distance Cycling Speed' }).on('change', () => applyParamsToNetwork(pn, PARAMS));
        // Gradient Effect
        const bindGradientEffect = mainLines.addBinding(PARAMS, 'gradientEffect', { label: 'Gradient Color Effect' }).on('change', () => {
          if (PARAMS.gradientEffect) {
            PARAMS.useDistanceEffect = false;
          }
          applyParamsToNetwork(pn, PARAMS);
          updateVisibility();
        });
        const bindGradient1 = mainLines.addBinding(PARAMS, 'gradientColor1', { view: 'color', label: 'Gradient Color 1' }).on('change', () => applyParamsToNetwork(pn, PARAMS));
        const bindGradient2 = mainLines.addBinding(PARAMS, 'gradientColor2', { view: 'color', label: 'Gradient Color 2' }).on('change', () => applyParamsToNetwork(pn, PARAMS));
        const bindLineColorCycling = mainLines.addBinding(PARAMS, 'lineColorCycling', { label: 'Line Color Cycling' }).on('change', () => { applyParamsToNetwork(pn, PARAMS); updateVisibility(); });
        const bindLineCyclingSpeed = mainLines.addBinding(PARAMS, 'lineCyclingSpeed', { min: 0, max: 100, step: 1, label: 'Line Color Cycling Speed' }).on('change', () => applyParamsToNetwork(pn, PARAMS));
        
        mainLines.addBinding(PARAMS, 'lineConnectionDistance', { min: 20, max: 300, step: 5, label: 'Line Connection Distance' }).on('change', () => applyParamsToNetwork(pn, PARAMS));
        mainLines.addBinding(PARAMS, 'colorDifferentiationMethod', { 
          label: 'Color Differentiation Method',
          options: {
            "Hue Distance": 'hueDistance', 
            Complementary: 'complementary', 
            Triadic: 'triadic', 
            Analogous: 'analogous', 
            "Lab Perceptual": 'labPerceptual', 
            "WCAG Contrast": 'wcagContrast'
          }
        }).on('change', () => {
          // Regenerate colors when method changes
          if (pn && pn.regenerateLineColors) {
            pn.regenerateLineColors();
          }
          applyParamsToNetwork(pn, PARAMS);
        });
        // Effects (combined)
        const mainEffects = main.addFolder({ title: 'Effects', expanded: true });
        mainEffects.addBinding(PARAMS, 'trails', { label: 'Trails (Hide Lines)' }).on('change', () => applyParamsToNetwork(pn, PARAMS));
        mainEffects.addBinding(PARAMS, 'trailFade', { min: 0.01, max: 0.3, step: 0.01, label: 'Trail Fade' }).on('change', () => applyParamsToNetwork(pn, PARAMS));
        const bindLineJitter = mainEffects.addBinding(PARAMS, 'lineJitter', { label: 'Electric Lines' }).on('change', () => { applyParamsToNetwork(pn, PARAMS); updateVisibility(); });
        const bindJitterSegments = mainEffects.addBinding(PARAMS, 'lineJitterSegments', { min: 6, max: 24, step: 1, label: 'Jitter Segments' }).on('change', () => applyParamsToNetwork(pn, PARAMS));
        const bindJitterAmplitude = mainEffects.addBinding(PARAMS, 'lineJitterAmplitude', { min: 0.0, max: 0.5, step: 0.01, label: 'Jitter Amplitude' }).on('change', () => applyParamsToNetwork(pn, PARAMS));

        // Particles
        const mainParticles = main.addFolder({ title: 'Particles', expanded: true });
        mainParticles.addBinding(PARAMS, 'particleSize', { min: 1, max: 8, step: 1, label: 'Size' }).on('change', () => applyParamsToNetwork(pn, PARAMS));
        mainParticles.addBinding(PARAMS, 'particleColor', { view: 'color', label: 'Particle Color' }).on('change', () => applyParamsToNetwork(pn, PARAMS));
        // Random particle color removed
        const bindParticleColorCycling = mainParticles.addBinding(PARAMS, 'particleColorCycling', { label: 'Particle Color Cycling' }).on('change', () => { applyParamsToNetwork(pn, PARAMS); updateVisibility(); });
        const bindParticleCyclingSpeed = mainParticles.addBinding(PARAMS, 'particleCyclingSpeed', { min: 0, max: 10, step: 0.1, label: 'Particle Color Cycling Speed' }).on('change', () => applyParamsToNetwork(pn, PARAMS));

        // Particle collisions and forces
        const bindParticleCollision = mainParticles.addBinding(PARAMS, 'particleCollision', { label: 'Particle Collision' }).on('change', () => { applyParamsToNetwork(pn, PARAMS); updateVisibility(); });
        const bindParticleAttraction = mainParticles.addBinding(PARAMS, 'particleAttraction', { label: 'Particle Attraction' }).on('change', () => {
          if (PARAMS.particleAttraction) {
            PARAMS.particleRepulsion = false;
            bindParticleRepulsion.refresh();
          }
          applyParamsToNetwork(pn, PARAMS);
          updateVisibility();
        });
        const bindParticleRepulsion = mainParticles.addBinding(PARAMS, 'particleRepulsion', { label: 'Particle Repulsion' }).on('change', () => {
          if (PARAMS.particleRepulsion) {
            PARAMS.particleAttraction = false;
            bindParticleAttraction.refresh();
          }
          applyParamsToNetwork(pn, PARAMS);
          updateVisibility();
        });
        const bindParticleInteractionDistance = mainParticles.addBinding(PARAMS, 'particleInteractionDistance', { min: 0, max: 200, step: 1, label: 'Interaction Distance' }).on('change', () => applyParamsToNetwork(pn, PARAMS));
        const bindParticleAttractionForce = mainParticles.addBinding(PARAMS, 'particleAttractionForce', { min: 0, max: 20, step: 0.5, label: 'Attraction Force' }).on('change', () => applyParamsToNetwork(pn, PARAMS));
        const bindParticleRepulsionForce = mainParticles.addBinding(PARAMS, 'particleRepulsionForce', { min: 0, max: 20, step: 0.5, label: 'Repulsion Force' }).on('change', () => applyParamsToNetwork(pn, PARAMS));

        // Lines
        const adv = tabs.pages[1];

        // Effects
        // Motion
        const motionMain = adv.addFolder({ title: 'Motion', expanded: true });
        motionMain.addBinding(PARAMS, 'speed', { min: 0, max: 2, step: 0.01, label: 'Speed' }).on('change', () => applyParamsToNetwork(pn, PARAMS));
        motionMain.addBinding(PARAMS, 'boundaryMode', { label: 'Boundary Mode', options: { bounce: 'bounce', wrap: 'wrap', none: 'none' }}).on('change', () => applyParamsToNetwork(pn, PARAMS));
        const bindCurvedDrift = motionMain.addBinding(PARAMS, 'curvedDrift', { label: 'Curved Drift' }).on('change', () => { applyParamsToNetwork(pn, PARAMS); updateVisibility(); });
        const bindCurvedCurv = motionMain.addBinding(PARAMS, 'curvedDriftCurvature', { min: 1, max: 100, step: 1, label: 'Curve Intensity' }).on('change', () => applyParamsToNetwork(pn, PARAMS));
        const bindCurvedNoise = motionMain.addBinding(PARAMS, 'curvedDriftNoiseSpeed', { min: 0.1, max: 4.0, step: 0.1, label: 'Noise Speed' }).on('change', () => applyParamsToNetwork(pn, PARAMS));

        // Moved gather control into Interaction as Attraction Radius

        // Interaction
        const inter = adv.addFolder({ title: 'Interaction', expanded: true });
        const bindInteractive = inter.addBinding(PARAMS, 'interactive', { label: 'Interactive' })
          .on('change', () => { applyParamsToNetwork(pn, PARAMS); updateVisibility(); });

        // Gather (top-level in Interaction)
        const bindGatherRadius = inter.addBinding(PARAMS, 'gatherRadius', { min: 0, max: 500, step: 1, label: 'Gather Radius' })
          .on('change', () => applyParamsToNetwork(pn, PARAMS));

        // Pointer highlight (formerly Proximity Effect)
        const proximityFolder = inter.addFolder({ title: 'Pointer Highlight', expanded: true });
        const bindProxColor = proximityFolder.addBinding(PARAMS, 'proximityEffectColor', { view: 'color', label: 'Highlight Color' })
          .on('change', () => applyParamsToNetwork(pn, PARAMS));
        const bindProxDistance = proximityFolder.addBinding(PARAMS, 'proximityEffectDistance', { min: 20, max: 250, step: 5, label: 'Highlight Distance' })
          .on('change', () => applyParamsToNetwork(pn, PARAMS));

        const mouseForces = inter.addFolder({ title: 'Mouse Forces', expanded: true });
        const bindAttractionRange = mouseForces.addBinding(PARAMS, 'attractionRange', { min: 0, max: 300, step: 5, label: 'Repulsion Radius (px)' })
          .on('change', () => applyParamsToNetwork(pn, PARAMS));
        const bindAttractionIntensity = mouseForces.addBinding(PARAMS, 'attractionIntensity', { min: 0, max: 30, step: 0.5, label: 'Repulsion Intensity' })
          .on('change', () => applyParamsToNetwork(pn, PARAMS));
        const bindRepulsionRange = mouseForces.addBinding(PARAMS, 'repulsionRange', { min: 0, max: 300, step: 5, label: 'Attraction Radius (px)' })
          .on('change', () => applyParamsToNetwork(pn, PARAMS));
        const bindRepulsionIntensity = mouseForces.addBinding(PARAMS, 'repulsionIntensity', { min: 0, max: 30, step: 0.5, label: 'Attraction Intensity' })
          .on('change', () => applyParamsToNetwork(pn, PARAMS));

        // Dependent visibility logic
        function updateVisibility() {
          // Gradient colors visible only when gradient effect is on
          bindGradient1.hidden = !PARAMS.gradientEffect;
          bindGradient2.hidden = !PARAMS.gradientEffect;
          // Show line cycling speed only when cycling is enabled
          const lineCycleOn = !!PARAMS.lineColorCycling;
          bindLineCyclingSpeed.hidden = !lineCycleOn;
          // Mutual exclusion handled by on-change; keep both toggles enabled
          // Show particle cycling speed only when particle cycling is enabled
          const particleCycleOn = !!PARAMS.particleColorCycling;
          bindParticleCyclingSpeed.hidden = !particleCycleOn;
          // Show inter-particle interaction controls
          const particleRepulsionOn = !!PARAMS.particleRepulsion;
          const particleAttractionOn = !!PARAMS.particleAttraction;
          bindParticleInteractionDistance.hidden = !(particleRepulsionOn || particleAttractionOn);
          bindParticleRepulsionForce.hidden = !particleRepulsionOn;
          bindParticleAttractionForce.hidden = !particleAttractionOn;
          // Distance Effect children
          const distOn = !!PARAMS.useDistanceEffect;
          bindMaxColorDist.hidden = !distOn;
          bindStartColor.hidden = !distOn;
          bindEndColor.hidden = !distOn;
          bindRandDistColors.hidden = !distOn;
          bindDistCycleSpeed.hidden = !distOn;
          // Electric lines advanced controls
          const jitterOn = !!PARAMS.lineJitter;
          bindJitterSegments.hidden = !jitterOn;
          bindJitterAmplitude.hidden = !jitterOn;
          // Curved drift controls hidden when off (keep Attraction Radius visible)
          const curvedOn = !!PARAMS.curvedDrift;
          bindCurvedCurv.hidden = !curvedOn;
          bindCurvedNoise.hidden = !curvedOn;
          // Interaction: hide dependents when Interactive is OFF
          const interactiveOn = !!PARAMS.interactive;
          bindGatherRadius.hidden = !interactiveOn;
          bindProxColor.hidden = !interactiveOn;
          bindProxDistance.hidden = !interactiveOn;
          bindAttractionRange.hidden = !interactiveOn;
          bindAttractionIntensity.hidden = !interactiveOn;
          bindRepulsionRange.hidden = !interactiveOn;
          bindRepulsionIntensity.hidden = !interactiveOn;
        }
        updateVisibility();

        // Actions at bottom of Main tab
        const mainActions = main.addFolder({ title: 'Actions', expanded: true });
        const actionsRandBtn = mainActions.addButton({ title: 'Randomize Visuals' });
        actionsRandBtn.on('click', randomizeVisualParams);
        const actionsResetBtn = mainActions.addButton({ title: 'Reset to Default' });
        actionsResetBtn.on('click', doReset);
        const actionsResetEffectsBtn = mainActions.addButton({ title: 'Reset Effects Only' });
        actionsResetEffectsBtn.on('click', () => {
          PARAMS.trails = DEFAULTS.trails;
          PARAMS.trailFade = DEFAULTS.trailFade;
          PARAMS.lineJitter = DEFAULTS.lineJitter;
          PARAMS.lineJitterSegments = DEFAULTS.lineJitterSegments;
          PARAMS.lineJitterAmplitude = DEFAULTS.lineJitterAmplitude;
          PARAMS.curvedDrift = DEFAULTS.curvedDrift;
          PARAMS.curvedDriftCurvature = DEFAULTS.curvedDriftCurvature;
          PARAMS.curvedDriftNoiseSpeed = DEFAULTS.curvedDriftNoiseSpeed;
          applyParamsToNetwork(pn, PARAMS);
          if (typeof pane.refresh === 'function') pane.refresh();
        });

        // Runtime ‚Üí UI sync without feedback loops
        const rgbArrayToHex = (arr) => {
          if (!arr || arr.length < 3) return '#000000';
          const r = Math.max(0, Math.min(255, Math.round(arr[0])));
          const g = Math.max(0, Math.min(255, Math.round(arr[1])));
          const b = Math.max(0, Math.min(255, Math.round(arr[2])));
          const to2 = (n) => n.toString(16).padStart(2, '0');
          return `#${to2(r)}${to2(g)}${to2(b)}`;
        };

        let syncing = false;
        function syncRuntimeToControls() {
          if (!pn || syncing) { requestAnimationFrame(syncRuntimeToControls); return; }
          syncing = true;
          try {
          if (PARAMS.useDistanceEffect && PARAMS.randomizeDistanceColors && pn.startColorRgb && pn.endColorRgb) {
              PARAMS.startColor = rgbArrayToHex(pn.startColorRgb);
              PARAMS.endColor = rgbArrayToHex(pn.endColorRgb);
              bindStartColor && bindStartColor.refresh();
              bindEndColor && bindEndColor.refresh();
            }
            if (PARAMS.lineColorCycling && pn.currentLineColor1Rgb) {
              const color1Hex = rgbArrayToHex(pn.currentLineColor1Rgb);
              PARAMS.gradientColor1 = color1Hex;
              if (PARAMS.gradientEffect && pn.currentLineColor2Rgb) {
                PARAMS.gradientColor2 = rgbArrayToHex(pn.currentLineColor2Rgb);
              } else {
                // When gradient effect is off, mirror color1
                PARAMS.gradientColor2 = color1Hex;
              }
              bindGradient1 && bindGradient1.refresh();
              bindGradient2 && bindGradient2.refresh();
            }
            // Sync particle color control to cycling hue when particle cycling is enabled
            if (PARAMS.particleColorCycling && typeof pn.options.particleHue === 'number') {
              const h = ((pn.options.particleHue % 360) + 360) % 360;
              if (window.ColorUtils && window.ColorUtils.hslToRgb) {
                const rgb = window.ColorUtils.hslToRgb(h, 100, 50);
                const to2 = (n) => Math.max(0, Math.min(255, Math.round(n))).toString(16).padStart(2, '0');
                PARAMS.particleColor = `#${to2(rgb.r)}${to2(rgb.g)}${to2(rgb.b)}`;
              }
            }
          } finally {
            syncing = false;
            requestAnimationFrame(syncRuntimeToControls);
          }
        }
        requestAnimationFrame(syncRuntimeToControls);

        // Legacy bindings removed in favor of tabs above

        // Legacy motion bindings removed in favor of tabs above

        // Randomize visuals (no interaction, no background, no speed, no particle amount)
        function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
        function rand01() { return Math.random(); }
        function randBool(p=0.5) { return Math.random() < p; }
        function randHex() {
          const to2 = (n) => n.toString(16).padStart(2, '0');
          const r = randInt(0,255), g = randInt(0,255), b = randInt(0,255);
          return `#${to2(r)}${to2(g)}${to2(b)}`;
        }
        const colorMethods = ['hueDistance','complementary','triadic','analogous','labPerceptual','wcagContrast'];

        function randomizeVisualParams() {
          // Particles
          PARAMS.particleSize = randInt(1, 6);
          // Random particle color removed: set a random static color only when not cycling
          if (!PARAMS.particleColorCycling) {
            PARAMS.particleColor = randHex();
          }
          PARAMS.opacity = Math.round((0.4 + rand01()*0.6) * 100) / 100; // 0.4..1.0
          // Only vary particle cycling speed if particle cycling is enabled
          if (PARAMS.particleColorCycling) {
            PARAMS.particleCyclingSpeed = randInt(0, 100);
          }

          // Lines
          // If distance effect is ON, keep gradientEffect OFF to avoid conflict; otherwise randomize gradientEffect
          if (!PARAMS.useDistanceEffect) {
            PARAMS.gradientEffect = randBool();
          } else {
            PARAMS.gradientEffect = false;
          }
          PARAMS.gradientColor1 = randHex();
          PARAMS.gradientColor2 = randHex();
          // Do not toggle lineColorCycling; only tweak speed
          PARAMS.lineCyclingSpeed = randInt(0, 100);
          
          PARAMS.lineConnectionDistance = randInt(60, 220);
          PARAMS.colorDifferentiationMethod = colorMethods[randInt(0, colorMethods.length-1)];

          // Distance effect (visual only)
          // Keep flags as-is (user choice). Only tweak colors/speeds.
          // Ensure randomizeDistanceColors defaults to true when distance effect is enabled
          if (PARAMS.useDistanceEffect) {
            PARAMS.randomizeDistanceColors = true;
          }
          PARAMS.startColor = randHex();
          PARAMS.endColor = randHex();
          PARAMS.maxColorChangeDistance = randInt(60, 240);
          PARAMS.distanceColorCyclingSpeed = randInt(0, 100);

          // Effects
          // 25% chance to enable trails
          PARAMS.trails = randBool(0.25);
          PARAMS.trailFade = Math.round((0.03 + rand01()*0.18) * 100) / 100; // 0.03..0.21
          PARAMS.lineJitter = randBool();
          PARAMS.lineJitterSegments = randInt(4, 14);
          PARAMS.lineJitterAmplitude = Math.round((0.06 + rand01()*0.18) * 100) / 100; // 0.06..0.24
          PARAMS.curvedDrift = randBool();
          PARAMS.curvedDriftCurvature = Math.round((0.05 + rand01()*0.25) * 100) / 100; // 0.05..0.3
          PARAMS.curvedDriftNoiseSpeed = Math.round((0.5 + rand01()*2.5) * 10) / 10; // 0.5..3.0

          // Respect constraints from distance effect: if distanceEffect ON, keep gradientEffect OFF
          if (PARAMS.useDistanceEffect) {
            PARAMS.gradientEffect = false;
          }
          applyParamsToNetwork(pn, PARAMS);
          if (typeof pane.refresh === 'function') pane.refresh();
        }

        // Legacy action buttons removed in favor of tabs above

        // --- Unified Key Controls ---
        function togglePane() {
          const isHidden = container.style.display === 'none';
          const showing = isHidden;
          container.style.display = showing ? 'block' : 'none';
          if (showing) {
            // Fade away the features-tiles section once controls are shown
            const features = document.querySelector('.features-tiles.section');
            if (features && !features.dataset.hidden) {
              features.style.transition = features.style.transition || 'opacity 400ms ease';
              features.style.opacity = '0';
              features.style.pointerEvents = 'none';
              setTimeout(() => {
                features.style.display = 'none';
                features.dataset.hidden = '1';
              }, 420);
            }
          }
        }
        // Bottom-right hotkey guide (H)
        let _guideTimeout = null;
        function showHotkeyGuide() {
          const existing = document.getElementById('hotkey-guide');
          if (existing && existing.parentNode) existing.parentNode.removeChild(existing);
          const guide = document.createElement('div');
          guide.id = 'hotkey-guide';
          guide.textContent = [
            'Shortcuts:',
            'C = Toggle Controls',
            'P = Performance Overlay',
            'R = Randomize Visuals',
            'D = Reset to Default',
            'A = Attract (hold)',
            'Left click = Repel',
            'Right click = Attract'
          ].join('\n');
          guide.style.cssText = "position:fixed; bottom:10px; right:10px; background:rgba(0,0,0,0.7); color:white; padding:8px 12px; border-radius:4px; font-family:'Fira Code',monospace; z-index:4000; white-space:pre;";
          document.body.appendChild(guide);
          if (_guideTimeout) { clearTimeout(_guideTimeout); _guideTimeout = null; }
          _guideTimeout = setTimeout(() => { if (guide.parentNode) guide.parentNode.removeChild(guide); }, 3000);
        }
        window.addEventListener('keydown', (e) => {
          const key = e.key.toLowerCase();
          // avoid conflicts when typing in text inputs
          if (e.target && e.target.tagName === 'INPUT' && e.target.type === 'text') return;

          switch (key) {
            case 'c':
              togglePane();
              break;
            case 'p':
              e.preventDefault();
              PARAMS.performanceOverlay = !PARAMS.performanceOverlay;
              applyParamsToNetwork(pn, PARAMS);
              if (typeof pane.refresh === 'function') pane.refresh();
              // Status toast top-right
              const statusIndicator = document.createElement('div');
              statusIndicator.textContent = `Performance Overlay: ${PARAMS.performanceOverlay ? 'Enabled' : 'Disabled'}`;
              statusIndicator.style.cssText = "position:fixed; top:10px; right:10px; background:rgba(0,0,0,0.7); color:white; padding:8px 12px; border-radius:4px; font-family:'Fira Code',monospace; z-index:4000;";
              document.body.appendChild(statusIndicator);
              setTimeout(() => { if (statusIndicator.parentNode) document.body.removeChild(statusIndicator); }, 1500);
              break;
            case 'r':
              // Randomize visuals via hotkey R
              randomizeVisualParams();
              break;
            case 'd':
              // Reset to default via hotkey D
              doReset();
              break;
            case 'h':
              // Show hotkey guide bottom-right
              showHotkeyGuide();
              break;
            default:
              break;
          }
        });
      });
    </script>
  </body>
</html>
